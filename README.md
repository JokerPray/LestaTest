Краткая характеристика предложенных ответов:
1) Единственным способом создания функции, суть которой состоит в определении четности числа было побитовое сравнение, суть проста число переводится в битовое значение и сравнивается самый младший бит, 
соответственно если результат побитовой операции '&' будет равен 1 число нечетное, а если 0 число четное. 

2) Второй вопрос был самым сложным, я никогда не сталкивался с такими конструкциями как циклические буферы, однако постарался сделать классический и масочный вариант.
    *Классический циклический буфер* имеет стандартные особенности присущие своей логической консрукции:       
* **Эффективное использование памяти:** Циклический буфер позволяет использовать один и тот же участок памяти для хранения данных, что снижает потребление памяти, особенно для больших объемов данных.
* **Постоянное время доступа:** Операции добавления (enqueue) и удаления (dequeue) элемента из циклического буфера выполняются за постоянное время, что делает его эффективным для задач, требующих быстрого доступа к данным.
*  **Без свободного места:** В этом варианте буфер считается "полным", когда он полностью заполнен, и только тогда при попытке добавить элемент возникает исключение.

    *Масочный циклический буфер* мысль о создании такой реализации пришла мне из первого задания, его отличительные черты:
 * **Эффективность:** Использование битовой маски для инкрементирования `self.head` и `self.tail`  делает эту реализацию более эффективной, чем предыдущий вариант. Битовые операции  обычно  быстрее,  чем  арифметические.
 * * **Ограничение:**  Емкость буфера должна быть степенью двойки. Если емкость не является степенью двойки, то `self.mask` будет иметь значение, которое не подходит для ограничения индексов.
 *  * С одним свободным местом: В этом варианте буфер считается "полным", когда остается 1 свободное место. Это позволяет избежать "ложных срабатываний" при добавлении элемента, когда буфер фактически заполнен.
      
3) Я выбрал метод быстрой сортировки, так как он имеет довольно понятную структуру, быструю реализацию и достаточную эффективность.
   
